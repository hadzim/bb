/*
 * dallas.cpp
 *
 *  Created on: Feb 3, 2013
 *      Author: root
 */

#include "ds18b20.h"

inline __attribute__((gnu_inline)) void ds18b20_bus_low(void) {
	DS18B20_PORT &= ~(1 << DS18B20_DQ);
	DS18B20_DDR |= (1 << DS18B20_DQ);
}

inline __attribute__((gnu_inline)) void ds18b20_bus_high(void) {
	DS18B20_PORT |= (1 << DS18B20_DQ);
	DS18B20_DDR &= ~(1 << DS18B20_DQ);
}

unsigned char ds18b20_reset_pulse(void) {
	unsigned char presence_status = 1;

	ds18b20_bus_low();
	_delay_us(480);

	ds18b20_bus_high();
	_delay_us(60);

	presence_status = DS18B20_PIN & (1 << DS18B20_DQ);
	_delay_us(420);

	return presence_status;
}

void ds18b20_write(unsigned char data) {
	unsigned char i;

	for (i = 0; i < 8; i++) {
		if (data & (1 << i)) {
			ds18b20_bus_low();
			_delay_us(10);
			ds18b20_bus_high();
			_delay_us(45);
		} else {
			ds18b20_bus_low();
			_delay_us(55);
			ds18b20_bus_high();
			_delay_us(5);
		}
	}

	_delay_us(5);
}

unsigned char ds18b20_read(void) {
	unsigned char i;
	unsigned char data = 0;

	for (i = 8; i > 0; i--) {
		data >>= 1;

		if (i == 8)
			data = 0;

		ds18b20_bus_low();
		_delay_us(5);
		ds18b20_bus_high();
		_delay_us(10);

		if (!(DS18B20_PIN & (1 << DS18B20_DQ)))
			data |= 0x00;
		else if (DS18B20_PIN & (1 << DS18B20_DQ))
			data |= 0x80;

		_delay_us(45);
	}

	return data;
}

void ds18b20_wait_to_convert(void) {
	ds18b20_bus_high();

	while (1) {
		ds18b20_bus_low();
		_delay_us(6);
		ds18b20_bus_high();
		_delay_us(10);

		if (!(DS18B20_PIN & (1 << DS18B20_DQ)))
			continue;
		else if (DS18B20_PIN & (1 << DS18B20_DQ))
			break;
		else
			continue;

		_delay_us(54);
	}
}

void ds18b20_get_temp(char* buff) {
	unsigned char low_byte;
	unsigned char high_byte;

	unsigned char sign;
	unsigned int decimal;
	unsigned int integer;

	ds18b20_reset_pulse();
	ds18b20_write(DS18B20_SKIPROM);
	ds18b20_write(DS18B20_CONVERTTEMP);

	ds18b20_wait_to_convert();

	ds18b20_reset_pulse();
	ds18b20_write(DS18B20_SKIPROM);
	ds18b20_write(DS18B20_RSCRATCHPAD);

	low_byte = ds18b20_read();
	_delay_us(5);
	high_byte = ds18b20_read();
	ds18b20_reset_pulse();

	if (high_byte & (0xF0))
		sign = 1;
	else
		sign = 0;

	decimal = (low_byte & 0x0F) * 625;

	high_byte &= 0x07;
	high_byte <<= 4;
	low_byte >>= 4;
	low_byte &= 0x0F;
	integer = low_byte | high_byte;

	if (sign == 0)
		sprintf(buff, "%u.%04u", integer, decimal);
	else if (sign == 1)
		sprintf(buff, "-%u.%04u", integer, decimal);
}
